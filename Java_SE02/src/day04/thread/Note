java语言的一个优势就是处理多线程比较简单
一般操作系统都支持同时执行多个程序，那么每个同时运行的程序对操作系统
而言称为一个进程，而对于一个程序而言，内部也可能运行多个任务，那么每个
同时运行的任务称为一个线程。

无论是进程还是线程，任务都是并发运行的，而不是纯粹的同时运行。
同时只是宏观上看

所谓并发，就是宏观上看所有任务都在同时运行，但微观上讲每个程序都是走走停停的
创建线程的步骤：
1 定义一个类，并继承Thread类
  Thread类是线程类，其中定义这操作线程的相关方法
2 重写run方法。该方法中应该定义的内容就是要并发运行代码片段
3 实例化线程并启动

并发执行过程：
当一个线程调用了start()方法时，该线程纳入线程调度机制得以并发运行
线程调度机制会分配时间片段，获得当前时间片段的线程被cpu执行，
当时间片段的时间耗尽，那么该线程等待，线程调度机制会再次分配时间片段给一个线程
这里要注意：
时间片段的时间不是完全均匀的，而且所有并发运行的任务获取时间片段的几率也是
不完全相同的，但线程调度机制会尽可能均匀的分配
一个线程获取时间片的长短，以及分配的次数是通过程序不可控的 

葛大爷同时排三步戏
很典型的现实版并发操作
联想：
CPU：葛大爷
线程调度机制：葛大爷的经纪人
时间片段：档期
线程：剧组

前面创建线程的方式有一个弊端，就是定义线程的时候就决定了线程要运行的任务。
我们应该尽可能避免线程与其要执行的任务关联性太强。
应该换一种思路：
任务就是任务，线程就是线程，线程只关心可以并发运行即可，给什么任务就并发运行什么任务。

线程常用方法
static void sleep(long time)
让当前线程进入睡眠阻塞time毫秒，当时间消耗完毕后，线程重新回到
runnable状态
void interrupt()
中断线程

final void setPriority(int p)
参数的取值范围：1-10
对应三个常量(优先级)
MAX_PRIORITY:10
NORM_PRIORITY:5
MIN_PRIORITY:1

守护线程(后台线程)
当一个进程中的所有线程运行完毕后，所有后台线程均要强制结束。
进程的结束：
当一个进程中的所有线程结束后，该线程结束。

线程安全问题：
由于多线程访问同一数据时可能出现线程安全问题，
我们就需要在访问数据的地方保证同步操作，
就是要有先后顺序，不能同时访问

synchronized关键字
当synchronized关键字修饰方法时，该方法变成同步方法，
多个线程不能同时执行该方法。
若修饰方法，那么锁对象是当前对象，换句话说就是给this上了个锁。

当一个类中声明的多个方法均被synchronized修饰，那么这些方法是互斥关系，
同一时间不可能被同时调用

若所有的方法均对方法进行同步，显然效率低下，在方法中，有时只有部分代码需要同步
这时候我们只需要同步这些代码即可，这样可以提高同步效率
语法：
 synchronized(同步监视器){}
同步监视器就是要上锁的对象。
通常使用的同步监视器(上锁的对象)是this

线程安全与不安全的类
线程安全的                    线程不安全的
StringBuffer                 StringBuilder
Vector                       ArrayList
HashTable                    HashMap

很多应用中都需要使用多线程，而有些情况当一个线程要完成的工作需要基于
另一个线程的工作情况时，我们则需要两个线程协调工作
以下方法是在Object中定义的
wait():在当前线程上等待
notify():通知一个在当前对象上等待的线程运行
notifyAll():通知所有在当前对象上等待的线程回到runnable状态










